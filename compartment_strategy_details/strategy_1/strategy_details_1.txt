**********************************************************************************************************************************************************

Doubts:
1). How are external functions named/used. Are they named as anonymous functions? My understanding is that, if the external definition is present in .mli file then the 
ocaml function corressponding to the external definition will also be generated instead of it being named as an anonymous function. But on inspecting the .s file
that was not the case. Instead, all the functions related to external definition were named as anonymous function. 
In many cases in ocaml-riscv, the external functions connect to asmrun functions which would be in 255. So if we take the step of assigning all anonymous functions with 254, then
cross-compartment calls would be disabled, which would not be the intended behaviour.
Eg: print_endline (8) -> camlStdlib__fun_234212 (254) -> caml_output_char (255) -> printf (4) : This sequence of calls won't work because of 254 assigned to 
camlStdlib__fun_234212. Moreover since camlStdlib__fun_234212 is just a stub which in turn invokes caml_output_char, part of asmrun, we should place the camlStdlib__fun_234212
also in 255. So, the problem can be solved by assigning camlStdlib__fun_234212 to compartment 8 or 255. This could be done by renaming the camlStdlib__fun_234212 to another 
function and then assign it the compartment explicitly. But the naming of external functions is not controlled by the programmer I guess. It needs compiler changes. So the
other way is to by default give all camlStdlib__fun_* functions a compartment ID of 255/non-254 compartment. For those camlStdlib__fun which you want to assign 254, which are
actually passed as parameters to higher-order functions can be renamed. 

2). "fun" functions are not only thunks but also, external functions, caml currying. In all these cases and few more(not yet found by me), name the functions as "fun". So
the best way to go forward is assign all the "fun" functions as 255, and explicitly rename all those thunks and assign compartment IDs to them as you wish.
Also, in point 1, I had mentioned that the problem can be solved by assigning all the "fun" functions to 255 or some other compartment. But 255 is the proper choice. Because, in 
a scenario where the C function is in another compartment w.r.t ocaml function invoking it. Then the external function "fun" (in ocaml), in which compartment should it be placed. 
This could be easily solved by having it in 255. 

3). Operators defined in stdlib.ml, like camlStdlib__.5e.5e_201386 should also be placed in C255. This we should look into later. For now everything placed in
	C254, unless an error occurs. camlStdlib__.5e.5e_201386 placed in C255.

4). Functions generated by compiler like caml_apply, caml_tuplify, caml_curry etc. by default placed in 254. No wrong in placing them in 255. For now everything placed in
	C254, unless an error occurs. Refer to ocaml-riscv/driver/compenv.ml for list of these functions that are placed in C255.
**********************************************************************************************************************************************************

Rules to compartmentalize "fun"/anonymous functions: 
1). Most of the list.iter, hashtbl functions etc... will be in 254. If the anonymous function is itself passed as parameter to 254 function, then no need to 
keep the anonymous function in 254. It will work properly in the non-254 compartment, provided it is in the same compartment that called 254. But to reduce 
overhead you may try assigning all the functions that the anonymous function uses to 254. 
2). When the anonymous function is passed as parameter to non-254 compartment, then you should be careful. If the anonymous function requires to invoke some 
other non-254 compartment, then it should be de-anonymized. You can try placing the function that would invoke the anonymous function in 254, if it doesn't 
invoke anything else other than 255/254 functions.

**********************************************************************************************************************************************************

ToDo:
1). All *__entry function need to be in 255. Those that are generated by the ocaml compiler need to be part of 255. 
	How is it done: Instead of searching for the "entry" phrase in emit.mlp, for now the we can have an entry in cap_tee file like 
	camlStdlib__array_:255 this would work as in emit.mlp takes the substring upto last '_' as the actual function name present in the hash table.
	This is the easiest way. Other ways include adding the logic whether "__entry" part of function name in emit.mlp itself or as part of get_cap_id() in
	compenv.ml file.
2). Annonymous functions end with like this: .type	camlStdlib__array__fun_20303. These are not explicitly mentioned as part of cap_tee file. By default 254 is 
applied to all functions which are not present in the hash table.
3). Tail-Call optimization
4). Disable capability on entering checkcap ISR.
5). If capability is disabled, then checkcap instruction should be treated as no-op and not an error.
6). If the get_cap_id in ocaml-riscv/driver/compenv.ml does not find the given function, then return a default 254.

**********************************************************************************************************************************************************

In this strategy we assume the following:
Assumptions:
1). The checkcap is modelled as an ISR
2). Limited context save
3). Saving/restoring initial registers for checking mcause and branching to corresponding exception is also not done, because we are using caller-saved 
	registers only and also no other interrupts/exceptions are handled currently other than checkcap. 

4). Exceptions are tricky to handle, for now any exception handling code that is part of ocaml-stdlib will be placed in 255, because then only 254 code can also 
call the exception handlers. The trap_handler() in trap.c will also be part of 255.

5). The htif_poweroff() will be in a separate compartment and only boot_primary() in startup.c will have access to it. Why this choice is taken is that, in an 
embedded environment scenario the device will have to function without any help in remote areas. In those situations the capability to poweroff the device is a 
highly priviliged choice. Any error if at all occurs, as KC told, should be handled via if-else or there should be a corresponding trap-handling mechanism.
That's why all the trap-handling related in C/ocaml are placed in the 255 compartment. Also, if you see, in the embedded environment scenario any of the error
messages would neither switch of the device nor print it(no screen would be there in the first place), it will log those messages on a separate buffer and 
transmit it to the server. More on this can be discussed when we we make a end-end application involving internet also.

6). Interrupts are not disabled currently when we implement the checkcap as an ISR.
7). Compartment numbering starts from 0.
8). Reserved compartments: 254 & 255.
9). Should set the INITIAL_COMPARTMENT & cap_matrix in defs.h and startup_2.c respectively of ocaml-boot-riscv.
10). No compartments as part of startup_1.S
11). INITIAL_COMPARTMENT -> 0x0 : boot_primary in startup_2.c
12). File-wise each function's allocation would be specified. Also, the compartment that it is allowed to call will be specified
13). All

**********************************************************************************************************************************************************

Compartment Allocations:
__________________________________________________________________________________________________________________________________________________________


I). Ocaml-Boot-Riscv:

C255 : NONE
	string.c
	trap.c

C0 : {C3} ==> Initial compartment, which has access to shutdown
	startup_2.c	

C1 : NONE ==> Access to mtimecmp set functions, used by timers
	timer.c

C2 : NONE ==> Access to system level print functions. Last level of print-related functions
	print.c
	uart.c 
	htif.c (Except htif_poweroff)

C3 : NONE ==> Access to shutdown
	htif.c/htif_poweroff
	compat.c/riscv_poweroff

C4 : {C2} ==> Interface to print-related functions
	compat.c/riscv_write

C5 : {C1} ==> Interface to mtimecmp set functions
	compat.c/riscv_wait

C6 : NONE ==> Interface to mtime 
	compat.c/riscv_clock_monotonic


Notes: 
1). The ocaml-boot-riscv interface functions will be part of ocaml-freestanding functions.
2). string.c can be either part of the 254 or 255 compartment. For now choosing 255.
3). riscv_wait and riscv_clock_monotonic can be in same compartment or different compartment. For now in different compartment, because 
	riscv_clock_monotonic returns only the clock value whereas riscv_wait allows the timer to be set.
4). print.c and htif.c/uart.c can be placed in different compartments also, but placing them in same compartment.

HINT :  There is a scope for compartment splitting whenever a interface is used. The interface function can either be in a separate compartment or can be merged 
either with the source compartment or destination compartment. Based on the security & performance tradeoff, a decision has to be taken.

__________________________________________________________________________________________________________________________________________________________


II). Ocaml-Freestanding-Riscv:

C255 : NONE
	asmrun & byterun
	
C254 : NONE ==> Commonly used utilities
	ctypes.c
	dtoa.c
	float.c
	memchr.c
	memcmp.c
	memcpy.c
	memmove.c
	memset.c
	strchr.c
	strcmp.c
	strlen.c
	strncpy.c
	strstr.c
	stpncpy.c
	strchrnul.c 
	strcspn.c
	strncmp.c
	strrchr.c
	strtol.c
	stubs.c
	sysdeps_riscv.c/sbrk
	sysdeps_riscv.c/dlmalloc functions

C0 : {C3} ==> Part of initial compartment
	sysdeps_riscv.c/nolibc_init

C3 : NONE ==> Access to shutdown
	sysdeps_riscv.c/exit
	sysdeps_riscv.c/abort

C4 : {C2} ==> Interface to print-related functions
	sysdeps_riscv.c/console_write
	sysdeps_riscv.c/write

C6 : NONE ==> Interface to mtime 
	sysdeps_riscv.c/gettimeofday
	sysdeps_riscv.c/times

C7 : {C4} ==> Access to actual C library functions lik eprintf used by applications
	fprintf.c
	printf.c
	vfprintf.c
	snprintf.c
	vsnprintf.c


Notes:
1). Compartment 254 which are like common utilities, to reduce performance impact. But for now placing it in different compartment. Later we can think of 
	enabling a feature where, based on the compartment which is calling, secure or not, based on that we can treat it as 254 or a different compartment.
2). sysdeps_riscv.c functions either can be placed in the same compartment as their corresponding compat.c functions or in different compartments. For now 
	placing it in the same compartment, as they finally call the compat.c functions anyways, so nothing wrong in placing them like that.
3). For now we treat snprintf and printf as same. But, snprintf does not print to stdout. So the proper way is to place them in different compartments. But the 
	tricky part is that both use vfprintf. Based on the write() passed, vfprintf either prints to stdout or to the string itself. So, if we place snprintf and 
	printf in 2 different compartments, then in which compartment to place vfprintf ? For now treating all *printf variants to be the same.
4). stubs.c : for now placing it in 254. Not sure in which compartment stubs.c should be placed, also didn't understand what its functionality is. For now 	
	placing it in 254.
5). sysdeps_riscv.c/nolibc_init is part of the boot_primary compartment.
6). The fprintf etc.. are placed in 7 for now. They can also be placed in same compartment as riscv_write, because anyway they are going to call that. Why 7 is 
chosen is that, the riscv_write and console_write in sysdeps_riscv.c are like interface functions. 

__________________________________________________________________________________________________________________________________________________________


III). Ocaml-Riscv:
Stdlib:

C255: 
	sys.mlp : only 5/6 functions in that almost all either just raise an exception or call an asmrun function, both of which are in 255. So placing all the functions
	  		  in sys.ml also in 255
	printexc.ml : any exception related code is in 255/254 so that any 254 code can also raise the exceptiion. But printing the exception message
							for uncaught_exceptions is not possible in the curent scheme, because all print to stdout, which is not the case usually where the 
							the error messages are logged separately.)
	std_exit.ml : not concentrating, had a brief look at it finally invokes the asmrun function only
				  what is the function of this, is it called at the end of every program always ? )
	stdlib.ml 

C254:
	arrayLabels.ml
	array.ml
	bigarray.ml 
	buffer.ml 
	bytesLabels.ml 
	bytes.ml 
	char.ml 
	callback.ml 
	complex.ml 
	digest.ml 
	ephemeron.ml 
	float.ml 
	gc.ml 
	genlex.ml 
	hashtbl.ml 
	int32.ml 
	int64.ml 
	lazy.ml 
	lexing.ml 
	listLabels.ml 
	list.ml 
	map.ml 
	moreLabels.ml 
	nativeint.ml 
	queue.ml 
	random.ml 
	stream.ml 
	stringLabels.ml 
	string.ml 
	uchar.ml 
	weak.ml 
	seq.ml 
	set.ml 
	sort.ml 
	spacetime.ml 
	stack.ml 
	stdLabels.ml 
	obj.ml 
	oo.ml 
	camlinternalLazy.ml 
	camlinternalMod.ml 
	camlinternalOO.ml 
	parsing.ml 
	marshal.ml 
	stdlib.ml 

C8 : {C7, C20} ==> Access to Ocaml related print functions (part of stdlib). Also, C8 needs access to C20, callback mechanism. kfprintf calls Mirage_Logs__k
	camlinternalFormatBasics.ml
	camlinternalFormat.ml
	printf.ml
	format.ml
	scanf.ml : not concentrating on this, as we dont use scanf currently
	stdlib.ml

C9 : NONE ==> Access to Command-line parameters. No command line support available for now 
	arg.ml : not concentrating, placing this in different compartment when compared to print/scan operations, as I feel 
			 accessing the command line is a different capability

C10: NONE ==> Access to File related operations
	filename.ml : not concentrating, for now in a different compartment w.r.t Printf/Scanf, but on the whole printf/scanf are also stdout-file related operations
	stdlib.ml

Notes:
1). Any ocaml related time function linked to compartment 6 or 5.
2). Any ocaml related print function linked to compartment 7 or 4.
3). Some functions within this might be placed in 255/254 based on their interaction with asmrun. Say, we have some function "A" that in turn invokes a GC 
function then that "A" need to be placed in 255 if required.
4). All callback.ml functions in 255, nothing it does mostly other than registering exceptions and callbacks.
5). All gc.ml functions are placed in 254 for now. Let's see whether it throws an error, if yes then try placing it in 255.
6). In camlinternalFormatBasics.ml only few functions are present, keeping them in compartment 8 instead of 254.
7). In camlinternalFormat.ml all the anonymous functions are also placed in compartment 8. This is done by explicitly specifying like this:
	camlCamlinternalFormat__fun:8 
	I hope this works. This would work, provided the same compartment invokes these anonymous functions. If these are invoked by another compartment, then the 
	overheads will be high, and they should be kept in 254 compartment. In this file, since it is an internal code (camlinternalFormat.ml), I assume that
	the anonymous functions would be invokde from the same compartment.
8). (refer to Doubts 1.) For now I am assigning all the camlStdlib__fun in stdlib.ml to compartment 255. There is not a set compartmentID that we can assign to them other than 
255/254 because the stdlib has file, read, write operations also, which for now are in different compartments. Later, we should look into this problem. 

__________________________________________________________________________________________________________________________________________________________


IV). Astring-riscv (Isolated)

C231
	all files

__________________________________________________________________________________________________________________________________________________________


V). 


__________________________________________________________________________________________________________________________________________________________

**********************************************************************************************************************************************************

Compartment Matrix:

0 : {C3}
1 : NONE
2 : NONE
3 : NONE
4 : {C2}
5 : {C1}
6 : NONE
7 : {C4}
8 : {C7}
9 : NONE
10 : NONE


231: NONE (Isolated)